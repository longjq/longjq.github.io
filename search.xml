<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[flask系列-3-模板]]></title>
    <url>%2F2017%2F08%2F05%2Fflask-jinja2%2F</url>
    <content type="text"><![CDATA[jinja2模板使用环境：CentOS 6.5 Python 2.7.13 Flask 0.12.2 Jinja2 2.9.6 一、准备工作flask的模板引擎使用一个名叫jinjia2的模板引擎，故需要使用PIP进行安装 1(venv2) $ pip install Flask==2.9.6 二、如何在Flask中使用Jinja2在flaskweb目录下新建一个templates目录，在该目录下新建一个jinja2.html文件，该文件名随意定 123(venv2) $ cd flaskweb(venv2) $ mkdir templates(venv2) $ touch jinja2.html jinja2.html的内容如下 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;jinja2 html&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &#123;&#123; txt &#125;&#125;&lt;/body&gt;&lt;/html&gt; 回到flaskweb的目录下，修改index.py文件 123456789101112131415161718from flask import Flask,render_templateapp = Flask(__name__)@app.route(&apos;/&apos;)def hello_world(): return &apos;Hello World!&apos;@app.route(&apos;/jinja2&apos;)def jinja2(): return render_template(&apos;jinja2.html&apos;, txt=&apos;This Text from Jinja2&apos;)if __name__ == &apos;__main__&apos;: # host指定访问IP，port指定端口，不填默认为127.0.0.1:5000 # debug设置调试模式，这样改了index.py文件，就不需要重启index.py文件 app.run(host=&apos;0.0.0.0&apos;,port=8080,debug=True) 访问127.0.0.1:8080/jinja2，返回jinja2函数定义中的txt值 三、jinja2的变量与过滤器变量输出变量使用的方式，Jinja2能识别很多类型，例如列表，字典，和对象等只有是能被str()方法转换成字符串即可 1234&lt;p&gt;字典类型：&#123;&#123; user[&apos;name&apos;] &#125;&#125;&lt;p&gt;&lt;p&gt;列表类型：&#123;&#123; user[0] &#125;&#125;&lt;p&gt;&lt;p&gt;对象类型：&#123;&#123; user.nick &#125;&#125;&lt;p&gt;&lt;p&gt;对象类型：&#123;&#123; user.get_money() &#125;&#125;&lt;p&gt; 过滤器对输出的变量进行处理 123456789101112131415161718192021222324252627282930313233343536&#123;# 注释，被包裹在这里面的内容不会被输出到最终的html #&#125;&#123;# default：当前变量未定义的时候返回default函数中定义的内容 #&#125;&#123;&#123; user.xxx | default(&apos;2017-08-05&apos;) &#125;&#125;&#123;# 如果变量带有html标签，默认jinja2会转义，不会显示原有标签的含义使用safe函数安全的进行转义，此时就可以输出原有标签的含义 #&#125;&#123;&#123; &apos;&lt;h1&gt;this &lt;b&gt;is&lt;/b&gt; string&lt;/h1&gt;&apos; | safe&#125;&#125;&#123;# 将变量转换成float类型输出 #&#125;&#123;&#123; 43 | float &#125;&#125;&#123;# 将list变量拼接，通list对象的方法一样 #&#125;&#123;&#123; [&apos;Python&apos;,&apos;SQLAlchemy&apos;] | join(&apos;,&apos;) &#125;&#125;&#123;# 将dict类型转换为json格式输出 #&#125;&#123;&#123; &#123;&apos;name&apos;:&apos;long&apos;,&apos;pass&apos;:123456,&apos;man&apos;:True&#125; | tojson &#125;&#125;&#123;# 字符串截断，只显示前几个，可惜该函数是按照字节处理，所以对英文支持度较好，中文则需要自己算字节长度 #&#125;&#123;&#123; &apos;Return a truncated copy of the string.&apos; | truncate(10)&#125;&#125;&#123;# 以下是一些判断表达式的过滤器 #&#125;&#123;# 判断user.post 是否为none，即没有赋值 #&#125;&#123;% if user.post is none %&#125; user.date is none&#123;% endif %&#125;&lt;br&gt;&#123;# 判断user.date 是否定义 #&#125;&#123;% if user.date is defined %&#125; user.xxx is none&#123;% endif %&#125;&lt;br&gt;&#123;# 判断user.age 与27是否相等 #&#125;&#123;% if user.age is equalto 27 %&#125; user.age is 27&#123;% endif %&#125; 官方还有很多的过滤器 Jinja2过滤器 自定义过滤器 自定义过滤器实现 定义一个过滤器，给定一个字符串，查找该字符串在另一个字符串中出现的次数 在模板文件中添加如下代码 12&#123;# count_substr即是我们定义的过滤器 #&#125;&#123;&#123; &apos;hello world!&apos; | count_substr(&apos;o&apos;) &#125;&#125; 在index.py中添加过滤器处理函数 12345# 函数名即是过滤器名，第一个参数是过滤的变量，第二个参数是过滤器传入的参数def count_substr(string, sub): return string.count(sub)# 将count_substr添加到jinja模板的过滤器字典中，便于在模板页面调用app.jinja_env.filters[&apos;count_substr&apos;] = count_substr 四、jingja2的if条件判断和for循环循环，同python的for一样使用 12345678910111213141516&#123;# 遍历posts，同时判断只有post.text有值的情况下才进行输出 #&#125;&#123;% for post in posts if post.text %&#125; &lt;div&gt; &lt;h1&gt;&#123;&#123; post.title &#125;&#125;&lt;/h1&gt; &lt;p&gt;&#123;&#123; post.text | safe &#125;&#125;&lt;/p&gt; &lt;/div&gt;&#123;% endfor %&#125;&#123;# 在循环内部有一个loop的特殊对象变量，可以输出遍历中的一些&quot;环境变量&quot; #&#125;&#123;% for post in posts if post.text %&#125; &lt;div&gt; &#123;# loop.index 输出遍历的序号，从1开始 #&#125; &lt;h1&gt;&#123;&#123;loop.index&#125;&#125; - &#123;&#123; post.title &#125;&#125;&lt;/h1&gt; &lt;p&gt;&#123;&#123; post.text | safe &#125;&#125;&lt;/p&gt; &lt;/div&gt;&#123;% endfor %&#125; 关于loop对象的说明 变量 描述 loop.index 当前循环迭代的次数（从 1 开始） loop.index0 当前循环迭代的次数（从 0 开始） loop.revindex 到循环结束需要迭代的次数（从 1 开始） loop.revindex0 到循环结束需要迭代的次数（从 0 开始） loop.first 如果是第一次迭代，为 True 。 loop.last 如果是最后一次迭代，为 True 。 loop.length 序列中的项目数。 loop.cycle 在一串序列间期取值的辅助函数。见下面的解释。 在 for 循环中，可以使用特殊的 loop.cycle 辅助函数，伴随循环在一个字符串/变 量列表中周期取值: 1234&#123;# 下面代码中每行都会有取odd或even其中一个值，例如当前取odd，下次取even，依次处理#&#125;&#123;% for row in rows %&#125; &lt;li class=&quot;&#123;&#123; loop.cycle(&apos;odd&apos;, &apos;even&apos;) &#125;&#125;&quot;&gt;&#123;&#123; row &#125;&#125;&lt;/li&gt;&#123;% endfor %&#125; 五、jinja2的宏macro宏macro定义了一块模板或者html代码，减少页面上重复的代码 例如在页面上定义如下代码 123456&#123;% macro input(name, label, value=&apos;&apos;, type=&apos;text&apos;) %&#125; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;&#123;&#123; name &#125;&#125;&quot;&gt;&#123;&#123; label &#125;&#125;&lt;/label&gt; &lt;input type=&quot;&#123;&#123; type &#125;&#125;&quot; name=&quot;&#123;&#123; name &#125;&#125;&quot; value=&quot;&#123;&#123; value | escape &#125;&#125;&quot;&gt; &lt;/div&gt;&#123;% endmacro %&#125; 在需要用到html的地方 1&#123;&#123; input(&apos;name&apos;,Name) &#125;&#125; 输出的时候，变成如下代码 1234&lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;name&quot;&gt;Name&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;&quot;&gt;&lt;/div&gt; 待续。。。 总结写了一半突然觉得花时间研究这些模板是真浪费时间，一路过来研究过Smarty、ThinkPHP的模板、Laravel的模板、Django模板，每个框架模板语法类似，又不通用，如果按照之前经验用又容易踩坑，所以，对于Web框架的模板我的理解就是。 如果不是维护需要，熟悉一套前端mvvm的框架还是非常必要，在现在SPA大行其道的今天，还在用模板套Html的方式，既不便于前端开发页面，也加大后端的开发难度。 回归HTML代码就是HTML，后端就是后端，二者用AJAX通信，减少耦合度！说了这多劳资就是被模板弄烦了而已，断更，就这样~]]></content>
      <categories>
        <category>flask</category>
      </categories>
      <tags>
        <tag>flask</tag>
        <tag>jinja2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flask系列-1-hello world]]></title>
    <url>%2F2017%2F08%2F05%2Fflask-hello-world%2F</url>
    <content type="text"><![CDATA[flask入门环境：CentOS 6.5 Python 2.7.13 Flask 0.12.2 一、准备工作使用virtualenv构建一个虚拟目录，然后使用PIP安装Flask 模块 1234$ virtualenv venv2$ cd venv2$ source bin/activate(venv2) $ pip install Flask==0.12.2 二、Flask的Hello World在虚拟目录venv2中新建一个文件夹flaskweb 12(venv2) $ mkdir flaskweb(venv2) $ cd flaskweb 在该文件夹下新建一个index.py文件，输入如下代码 12345678910from flask import Flaskapp = Flask(__name__)@app.route(&apos;/&apos;)def hello_world(): return &apos;Hello World!&apos;if __name__ == &apos;__main__&apos;: app.run() 执行如下命令启动，此时就可以通过127.0.0.1:5000网址访问网站 12(venv2) $ python index.py * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit) 三、总结使用virtualenv构建了flask的项目，并创建了一个返回hello world字符串的网页]]></content>
      <categories>
        <category>flask</category>
      </categories>
      <tags>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自用Vim配置注释版]]></title>
    <url>%2F2017%2F08%2F05%2Fvim-tool%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899set nocompatible &quot; 去除VI一致性,必须要添加filetype off &quot; 必须要添加&quot; 设置包括vundle和初始化相关的runtime path&quot; 使用vundle需要先git clone到本地&quot; 1、git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim&quot; 如果目录不存在，需要那就执行如下命令新建&quot; cd ~&quot; mkdir .vim&quot; cd .vim&quot; mkdir bundleset rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()&quot; 另一种选择, 指定一个vundle安装插件的路径&quot;call vundle#begin(&apos;~/some/path/here&apos;)&quot; 让vundle管理插件版本,必须Plugin &apos;VundleVim/Vundle.vim&apos;&quot; 以下范例用来支持不同格式的插件安装.&quot; 请将安装插件的命令放在vundle#begin和vundle#end之间.&quot; Github上的插件&quot; 格式为 Plugin &apos;用户名/插件仓库名&apos;&quot; Plugin &apos;tpope/vim-fugitive&apos;&quot; 来自 http://vim-scripts.org/vim/scripts.html 的插件&quot; Plugin &apos;插件名称&apos; 实际上是 Plugin &apos;vim-scripts/插件仓库名&apos; 只是此处的用户名可以省略&quot; Plugin &apos;L9&apos;&quot; 由Git支持但不再github上的插件仓库 Plugin &apos;git clone 后面的地址&apos;&quot; Plugin &apos;git://git.wincent.com/command-t.git&apos;&quot; 本地的Git仓库(例如自己的插件) Plugin &apos;file:///+本地插件仓库绝对路径&apos;&quot; Plugin &apos;file:///home/gmarik/path/to/plugin&apos;&quot; 插件在仓库的子目录中.&quot; 正确指定路径用以设置runtimepath. 以下范例插件在sparkup/vim目录下&quot; Plugin &apos;rstacruz/sparkup&apos;, &#123;&apos;rtp&apos;: &apos;vim/&apos;&#125;&quot; 安装L9，如果已经安装过这个插件，可利用以下格式避免命名冲突&quot; Plugin &apos;ascenator/L9&apos;, &#123;&apos;name&apos;: &apos;newL9&apos;&#125;&quot; 你的所有插件需要在下面这行之前call vundle#end() &quot; 必须filetype plugin indent on &quot; 必须 加载vim自带和插件相应的语法和文件类型相关脚本&quot; 忽视插件改变缩进,可以使用以下替代:&quot;filetype plugin on&quot;&quot; 常用的命令&quot; :PluginList - 列出所有已配置的插件&quot; :PluginInstall - 安装插件,追加 `!` 用以更新或使用 :PluginUpdate&quot; :PluginSearch foo - 搜索 foo ; 追加 `!` 清除本地缓存&quot; :PluginClean - 清除未使用插件,需要确认; 追加 `!` 自动批准移除未使用插件&quot;&quot; 查阅 :h vundle 获取更多细节和wiki以及FAQ&quot; 将你自己对非插件片段放在这行之后&quot; 自定义插件Plugin &apos;scrooloose/nerdtree&apos;&quot;Plugin &apos;Lokaltog/vim-powerline&apos;&quot; 插件设置&quot; NERDTreemap &lt;F2&gt; :NERDTreeToggle&lt;CR&gt;&quot;powerline&#123;set guifont=PowerlineSymbols\ for\ Powerlineset nocompatibleset t_Co=256let g:Powerline_symbols = &apos;fancy&apos;&quot;&#125;&quot; 自定义系统环境&quot;set cursorline &quot; 突出显示当前行set nu &quot; 显示行号set cursorline &quot; 高亮当前行 hi CursorLine cterm=NONE ctermbg=darkred ctermfg=white guibg=darkred guifg=white &quot; 当前行颜色&quot; set cursorcolumn &quot; 高亮当前列&quot; hi CursorColumn cterm=NONE ctermbg=darkred ctermfg=white guibg=darkred guifg=white &quot; 当前列颜色set shiftwidth=4 &quot;这个量是每行的缩进深度，一般设置成和tabstop一样的宽度&quot;set tabstop=4 &quot;设置Tab显示的宽度，Python建议设置成4&quot;&quot;刚才说过Tab和空格是不同的，虽然你可以在自己的代码中全部使用Tab&quot;&quot;&quot;但是如果你将你的代码分享给使用空格的朋友，就会带来很多麻烦&quot;&quot;那么设置下面这行就可以将Tab自动展开成为空格&quot;&quot;set expandtab&quot;&quot;如果只想在Python文件中将Tab展开成空格，就改换成下面这句&quot;autocmd FileType python set expandtab&quot;上面的一些配置已经可以让你避免编译出现错误的问题了&quot;&quot;&quot;&quot;不过下面还有一些配置是建议同学们根据需要加上的&quot;set smartindent &quot;智能缩进&quot;set cindent &quot;C语言风格缩进&quot;set autoindent &quot;自动缩进&quot;]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown]]></title>
    <url>%2F2017%2F08%2F05%2Fmarkdown-demo%2F</url>
    <content type="text"><![CDATA[我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown： 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载： Windows/Mac/Linux 全平台客户端 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 新文稿 或者使用快捷键 Ctrl+Alt+N。 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 支持以 PDF 格式导出文稿 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 新增 Todo 列表功能 修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式[^LaTeX]$$E=mc^2$$ 3. 高亮一段代码[^code]1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 4. 高效绘制 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 高效绘制 甘特图12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 7. 绘制表格 项目 价格 数量 计算机 \$1600 5 手机 \$12 12 管线 \$1 234 8. 更详细语法说明想要查看更详细的语法说明，可以参考我们准备的 Cmd Markdown 简明语法手册，进阶用户可以参考 Cmd Markdown 高阶语法手册 了解更多高级功能。 总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。 什么是 Cmd Markdown您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑/发布/阅读 Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。 1. 实时同步预览我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！ 2. 编辑工具栏也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。 3. 编辑模式完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右侧的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！ 4. 实时的云端文稿为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。 5. 离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。 6. 管理工具栏为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏： 通过管理工具栏可以： 发布：将当前的文稿生成固定链接，在网络上发布，分享 新建：开始撰写一篇新的文稿 删除：删除当前的文稿 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地 列表：所有新增和过往的文稿都可以在这里查看、操作 模式：切换 普通/Vim/Emacs 编辑模式 7. 阅读工具栏 通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。 工具栏上的五个图标依次为： 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落 视图：互换左边编辑区和右边预览区的位置 主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！ 阅读：心无旁骛的阅读模式提供超一流的阅读体验 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境 8. 阅读模式在 阅读工具栏 点击 或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。 9. 标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档： 标签： 未分类 标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示： 10. 文稿发布和分享在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 (Ctrl+Alt+P) 发布这份文档给好友吧！ 再一次感谢您花费时间阅读这份欢迎稿，点击 (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！ 作者 @ghosert2016 年 07月 07日 [^LaTeX]: 支持 LaTeX 编辑显示支持，例如：$\sum_{i=1}^n a_i=0$， 访问 MathJax 参考更多使用方法。 [^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web性能优化2]]></title>
    <url>%2F2017%2F07%2F30%2Fweb2%2F</url>
    <content type="text"><![CDATA[1、减少http请求a链接地图，减少图片链接css偏移内联图片：data:image/gif;base64,（ie不支持），css内联效果，.home{background:url(data:image/gif;base64,RHJGYURTYVHGF)} .home{background-image:(data:image/gif;base64,&lt;?php echo base64_encode(file_get_contents(“../images/home.gif”))?&gt;)}合并js，多个js合并为1个（使用模块化js的时候，最后输出为1个即可） 2、使用内容分发网络cdncdn主要用于静态文件，如图片，css，js和flash等cdn，自动寻找离物理机最近的服务器下载web组件。 3、添加expires头通常图片添加Expires ，指定一个日期，Expires：Thu，15 Apr 2020 20:20:20 GMT，在这之前图片不过期，继续使用缓存（考虑问题：客户端和服务器时钟同步的问题）http1.1支持 max-age，Cache-Control：max-age=315460000，未来10年内缓存不会过期（当同时使用Cache-Control和Expires的时候，max-age=XXX，会自动重写Expires的日期）apache的mod_expires，设置相对过期时间，它同时发送Expires和max-age ExpiresDefault “access plus 10 years”&gt;即是不添加expires头，浏览器也会缓存，下次访问时，为了验证是否过期，只是发送一个很小的头，来服务器验证是否更新而已 4、压缩组件Accept-Encoding：gzip，deflate web服务器基于这个参数来检测是否对响应进行压缩 代理缓存的处理，在使用代理的时候，代理服务器为避免缓存版本不一致，故添加Vary头，Vary：Accrpt-Encoding，让代理缓存多个版本，一个是指定gzip压缩的版本，一个是没有指定压缩的版本 5、将样式表放在顶部 6、将脚本放在底部 w3c建议，浏览器每个主机名并行连个组件的下载禁用css表达式，这样css样式代码和css表达式逻辑代码混杂在一起了 7、使用外部css和js动态内联：根据cookie来做内联和外部的引用的选择第一次访问：生成内联组件的页面，服务器添加js代码，供页面加载后动态下载外部文件同时设置cookie第二次访问：服务器读取到了cookie，就生成一个外部文件的页面返回客户端 8、减少dns查找通过使用Keep-Alive和较少的域名来减少dns查找 9、精简js和css使用jsmint和gzip精简文件，css精简技术点：#660066 优化 #606 ，使用0代替0px 10、避免重定向]]></content>
      <categories>
        <category>性能</category>
      </categories>
      <tags>
        <tag>Web2</tag>
        <tag>性能优化2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch配置文件]]></title>
    <url>%2F2017%2F07%2F29%2Felastic-conf%2F</url>
    <content type="text"><![CDATA[自动加载2.3版本开始，新增自动加载功能--auto-reload 12# 设置自动加载test.conf配置文件$ bin/logstash -f test.conf --auto-reload 默认每3秒监测一次配置文件，如果要修改该时间。 使用--reload-interval &lt;秒数&gt;参数 12# 设置每4秒读取一次test.conf配置文件$ bin/logstash -f test.conf --reload-interval 4]]></content>
      <categories>
        <category>Elastic</category>
      </categories>
      <tags>
        <tag>Elastic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch]]></title>
    <url>%2F2017%2F07%2F29%2Felastic%2F</url>
    <content type="text"><![CDATA[什么是Elasticsearch关于Elasticsearch的一些说明 Node（节点）：单个的装有Elasticsearch服务并提供故障转移和扩展的服务器 Cluster（集群）：一个集群就是由一个或多个node组织在一起，共同工作，共同分享整个数据具有负载均衡功能的集群 Document（文档）：一个文档是一个可被索引的基础信息单元 Index（索引）：索引就是一个拥有几分相似特征的文档集合 Type（类型）：一个索引中，你可以定义一种或躲着类型 Field（列）：Field是Elasticsearch的最小单位，相当于数据的某一列 Shards（分片）：Elasticsearch将索引分成若干份，每个部分就是一个shard Replicas（复制）：Replicas是索引一份或多份拷贝 与一般的关系型数据库的对比 关系型数据库（例如mysql） 非关系型数据库（Elasticsearch） 数据库Database 索引Index 表Table 类型Type 数据行Row 文档Document 数据列Column 字段Field 架构图 bulk批量操作 action（行为） 解释 create 当文档不存在时创建 index 创建新文档或替换已有的文档 update 局部更新文档 delete 删除一个文档 例：{&quot;delete&quot;:{&quot;_index&quot;:&quot;library&quot;,&quot;_type&quot;:&quot;books&quot;,&quot;_id&quot;:&quot;1&quot;}} 下面是一些批量操作 12345678910111213141516171819202122232425POST /librarys/books/_bulk&#123; &quot;index&quot;: &#123; &quot;_id&quot;:1 &#125; &#125;&#123; &quot;title&quot;:&quot;ELASTICSEARCH: THE DEFINETIVE GIDE2&quot;,&quot;price&quot;:5 &#125;&#123; &quot;index&quot;: &#123; &quot;_id&quot;:2 &#125; &#125;&#123; &quot;title&quot;:&quot;ELASTICSEARCH: cookbook2&quot;,&quot;price&quot;:51 &#125;&#123; &quot;index&quot;: &#123; &quot;_id&quot;:3 &#125; &#125;&#123; &quot;title&quot;:&quot;THINK IN PHP2&quot;,&quot;price&quot;:5 &#125;&#123; &quot;index&quot;: &#123; &quot;_id&quot;:4 &#125; &#125;&#123; &quot;title&quot;:&quot;THINK IN PATTERN&quot;,&quot;price&quot;:5 &#125;&#123; &quot;index&quot;: &#123; &quot;_id&quot;:5 &#125; &#125;&#123; &quot;title&quot;:&quot;HELLO WORLD&quot;,&quot;price&quot;:5 &#125;GET /librarys/books/_mget&#123; &quot;ids&quot; : [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;]&#125;POST /librarys/books/_bulk&#123; &quot;delete&quot;: &#123;&quot;_index&quot;: &quot;librarys&quot;, &quot;_type&quot;: &quot;books&quot;, &quot;_id&quot;: &quot;1&quot;&#125; &#125;&#123; &quot;create&quot;: &#123;&quot;_index&quot;: &quot;music&quot;,&quot;_type&quot;:&quot;classical&quot;,&quot;_id&quot;:&quot;1&quot;&#125;&#125;&#123; &quot;title&quot;: &quot;love is forvery&quot;&#125;&#123; &quot;index&quot;: &#123; &quot;_index&quot;: &quot;music&quot;, &quot;_type&quot;: &quot;classical&quot;&#125;&#125;&#123; &quot;title&quot;: &quot;live is forvery&quot;&#125;&#123; &quot;update&quot;: &#123; &quot;_index&quot;:&quot;librarys&quot;,&quot;_type&quot;:&quot;books&quot;,&quot;_id&quot;:&quot;2&quot;&#125;&#125;&#123; &quot;doc&quot;: &#123;&quot;price&quot;:&quot;99999&quot;&#125;&#125; PS:提交的Body数据必须一行一个action操作下一行为body数据，中间必须要用\n隔开 bulk处理文档大小的最佳值 数据加载在每个节点里的RAM里 请求的数据超过一定大小，那bulk的处理性能就会下降 文档数据大小跟硬件配置，文档复杂度，以及当前集群负载有关 PS:刚开始可以先处理小一点的数据，根据插件查看性能，如果没有问题再加大处理的数据 版本控制乐观锁和悲观锁悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作，并发量大的时候会产生性能阻塞，产生一些性能问题 乐观锁：假定不会发生并发冲突，只在提交操作时检查是否违反数据的完整性，如果提交时发现目标被修改了，会提交失败，同时会产生大量的查询操作，因为需要检查数据完整性，所以数据的实时性较差，读取的数据都是脏读、脏数据 内部版本和外部版本内部版本控制：使用自带的_version整型的自增长关键字，修改数据后，_version会自动加1 123456789101112131415161718192021222324252627282930# 新建一条数据，注意查看返回的_version关键字，版本为1PUT /librarys/books/1&#123; &quot;title&quot;: &quot;Elasticsearch: THE definetive guid&quot;, &quot;name&quot; : &#123; &quot;first&quot;:&quot;longjq&quot;, &quot;last&quot;:&quot;Tong&quot; &#125;, &quot;publish_date&quot;:&quot;2015-12-12&quot;, &quot;price&quot;:59.99&#125;# 查询id=1的数据，查看_version版本字段，版本为1GET /librarys/books/1# 修改id=1的数据中的字段，查看_version版本，版本为2，说明已修改成功POST /librarys/books/1/_update&#123; &quot;doc&quot;:&#123; &quot;price&quot;:15 &#125;&#125;# 指定修改id=1，version=2的数据，返回version=3，说明修改成功POST /librarys/books/1/_update?version=2&#123; &quot;doc&quot;:&#123; &quot;price&quot;:10 &#125;&#125; 外部版本控制：为了保持_version与外部版本控制的数值一致，使用version_type=external关键字，检查数据当前的version值是否小于请求中的version值，只有请求的version值大于数据中的version值的时候，才能修改成功 123456789101112131415161718192021222324# 覆盖操作，使用外部控制version_type=external参数，指定id=1的version的版本为version=15的版本PUT /librarys/books/1?version=15&amp;version_type=external&#123; &quot;title&quot;: &quot;Elasticsearch: THE definetive guid&quot;, &quot;name&quot; : &#123; &quot;first&quot;:&quot;longjq&quot;, &quot;last&quot;:&quot;Tong&quot; &#125;, &quot;publish_date&quot;:&quot;2015-12-12&quot;, &quot;price&quot;:33.33&#125;# 外部控制version版本与控制的版本一致时，操作失败，小于也失败，这里不演示，可自行操作，总而言之，给的version一定要大于数据中的version值PUT /librarys/books/1?version=15&amp;version_type=external&#123; &quot;title&quot;: &quot;Elasticsearch: THE definetive guid&quot;, &quot;name&quot; : &#123; &quot;first&quot;:&quot;longjq&quot;, &quot;last&quot;:&quot;Tong&quot; &#125;, &quot;publish_date&quot;:&quot;2015-12-12&quot;, &quot;price&quot;:33.33&#125;GET /librarys/books/1 PS:给定version时，其值必须为整型 Mapping 映射什么是Mapping映射就是类似于mysql的表结构，创建索引的时候，预先定义相关字段的类型以及相关的属性 PS：如果没有设置映射的话，Elasticsearch会自动分析数据内容，创建字段的映射，这里可以理解为手动设置映射关系 它有什么用让索引建立的更加细致和完善 映射的分类分为静态映射和动态映射 字段类型去官网查看 PS:记录该学习笔记的时候，使用的是Elasticsearch 2.3的版本 以下截图为常用字段，2.3版本新增了很多字段，建议去官网查看 属性方法去官网查看 除了定义字段类型，还可以给字段添加相关属性 如何理解这个属性方法？ 字段类型是约束存入的数据类型格式，属性方法是给该位置的字段添加相关的属性，属性不同会产生不同的效果，类似于mysql的default、主键、自增长 截图是常用属性方法 动态映射 什么是动态映射 文档中碰到一个以前没见过的字段时，动态映射自动决定该字段的类型，并对该字段添加映射 如何配置动态映射 通过dynamic属性进行控制 true：默认值，动态添加自动；false：忽略新自动；strict：碰到陌生自动，抛出异常。 适用范围 适用在根对象上或者object类型的任意字段上 代码演示 建立和查看映射 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# 建立映射POST /library&#123; "settings": &#123; "number_of_shards":5, "number_of_replicas": 1 &#125;, "mappings": &#123; "books": &#123; "properties": &#123; "title": &#123; "type": "string" &#125;, "name": &#123; "type": "string", "index": "not_analyzed" &#125;, "publish_date": &#123; "type": "date", "index" : "not_analyzed"&#125;, "price": &#123; "type": "double" &#125;, "number": &#123; "type": "integer" &#125; &#125; &#125; &#125;&#125;# 动态映射(注意：2.3的版本貌似已经修改，该处建议查看官网文档)PUT /library&#123; "mappings": &#123; "books": &#123; "dynamic": "strict", "properties": &#123; "title": &#123; "type": "string" &#125;, "name": &#123; "type": "string", "index": "not_analyzed" &#125;, "publish_date": &#123; "type": "date", "index" : "not_analyzed"&#125;, "price": &#123; "type": "double" &#125;, "number": &#123; "type": "object", "dynamic": true &#125; &#125; &#125; &#125;&#125;# 查看library索引信息，包含映射信息GET /library# 获取library索引映射信息GET /library/_mapping# 获取library索引下的books映射信息GET /library/_mapping/books# 获取整个集群内的索引信息GET /_all/_mapping# 获取整个集群内的type为books和music的映射信息GET /_all/_mapping/books,music 删除映射 123# 删除映射DELETE /library/books/_mappingDELETE /library/_mapping/books 更新映射 很遗憾，Mapping映射一旦建立，就不能修改！！！ 只能新建另外一个索引，然后将之前的数据导入到新的索引中 ————操作方法—————1.给现有索引定义一个别名，并且把现有的索引指向这个别名 1PUT /现有索引/_alias/别名A 2.新创建一个索引，定义好需要的映射 3.把别名指向新的索引，并取消之前的索引的指向 1234567POST /_aliases&#123; &quot;actions&quot;:[ &#123; &quot;remove&quot;: &#123; &quot;index&quot;: &quot;现有索引名&quot;,&quot;alias&quot;: &quot;别名A&quot; &#125; &#125;， &#123; &quot;add&quot;: &#123; &quot;index&quot;: &quot;新建索引名&quot;,&quot;alias&quot;: &quot;别名A&quot; &#125; &#125;， ]&#125; 通过以上三步骤可实现索引平衡过渡，且是零停机执行 查询基本查询利用Elasticsearch内置查询条件进行查询，文档最后有示例数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061GET /library/books/# 指定index名以及type名的搜索GET /library/books/_search?q=title:ELASTICSEARCH# 指定index名没有type名的搜索，跨type类型搜索GET /library/_search?q=title:ELASTICSEARCH# 没有index名也没有type名的搜索，跨index索引搜索GET /_search?q=title:ELASTICSEARCH#------------------------------------------------# term查询# term查询：查询某字段里有某个关键字的文档GET /library/books/_search&#123; "query": &#123; "term": &#123; "preview": "ut" &#125; &#125;&#125;# terms查询：查询某个字段有多个关键词的文档# minimum_match：最小匹配，1 说明两个关键词里最少要有一个 2 说明文档这两个关键词必须存在# minimum_match 该参数在2.3的版本中不支持在terms中使用了，请去官网查询GET /library/books/_search&#123; "query":&#123; "terms": &#123; "preview": [ "doloremque", "Odit" ], "minimum_match": 2 &#125; &#125;&#125;# -----------------------------------------------GET /library/books/_search?q=title:ELASTICSEARCH# 控制查询返回数量# 相当于mysql中的limit# form ：从哪个结果开始返回，2.3版本中，整型变量变成了对象，请去官网查询# size ：定义返回最大的结果数GET /library/books/_search&#123; "from": 0, "size": 20, "query": &#123; "term": &#123; "title": &#123; "value": "ELASTICSEARCH" &#125; &#125; &#125;&#125; 组合查询把多个基本查询组合在一起的复合性查询 过滤查询同时，通过filter条件在不影响打分的情况下筛选出想要的数据 library数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162[ &#123; "title": "minima", "price": 49.45, "preview": "Earum inventore velit quidem incidunt alias rem esse pariatur. Laborum sed quo nulla consectetur voluptatem consequatur delectus. Culpa quo tempora atque explicabo sed officia eos consequatur.", "publish_date": "2011-02-13" &#125;, &#123; "title": "eveniet", "price": 46.59, "preview": "Aliquam necessitatibus nostrum pariatur ut hic. Voluptatum rerum occaecati natus nostrum dolor. Quibusdam omnis quod voluptas nostrum.", "publish_date": "1986-10-27" &#125;, &#123; "title": "voluptatem", "price": 29.99, "preview": "Voluptatem a recusandae inventore error. Ut et beatae nulla enim saepe et. Pariatur fuga quam ut. Ducimus qui ut est ut dolor.", "publish_date": "2012-07-12" &#125;, &#123; "title": "tempore", "price": 74.42, "preview": "Eveniet facilis dolor repellat nesciunt eum quas. Ipsa ab harum et et. Autem fuga voluptas modi omnis ad et. Inventore in autem cum atque molestiae odit perferendis.", "publish_date": "1981-11-26" &#125;, &#123; "title": "voluptatem", "price": 99.97, "preview": "Dolores quis expedita libero id neque. Non est culpa perspiciatis repudiandae deserunt quaerat eius. Quo laboriosam officiis voluptate voluptas quia corporis ut.", "publish_date": "1987-01-05" &#125;, &#123; "title": "dolores", "price": 35.27, "preview": "Porro atque necessitatibus sed doloremque qui. Enim dolores illum dolorum qui incidunt.", "publish_date": "2006-03-19" &#125;, &#123; "title": "pariatur", "price": 22.87, "preview": "Quis facere blanditiis voluptatem at non aperiam ab ut. Voluptatum ipsum necessitatibus et et. Voluptatem culpa quia architecto. Deleniti aut officia temporibus est.", "publish_date": "1982-09-09" &#125;, &#123; "title": "et", "price": 37.13, "preview": "Odit doloremque magni accusamus cupiditate soluta nam assumenda qui. Labore nulla voluptatem reiciendis. Excepturi ex sapiente dolor aut totam provident. Velit et ut adipisci quaerat nihil qui.", "publish_date": "2015-09-25" &#125;, &#123; "title": "maxime", "price": 8.78, "preview": "Quaerat eos repudiandae inventore. Voluptates qui est illum ad sed. Necessitatibus ab pariatur quod.", "publish_date": "2011-10-31" &#125;, &#123; "title": "aspernatur", "price": 40.39, "preview": "Aut quibusdam tempora rerum. Doloremque tempore laborum dolores mollitia fugiat. Nemo blanditiis exercitationem occaecati modi repudiandae.", "publish_date": "2008-01-06" &#125;]]]></content>
      <categories>
        <category>Elastic</category>
      </categories>
      <tags>
        <tag>Elastic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F07%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[web性能优化]]></title>
    <url>%2F2017%2F07%2F29%2Fweb%2F</url>
    <content type="text"><![CDATA[1、减少http请求a链接地图，减少图片链接css偏移内联图片：data:image/gif;base64,（ie不支持），css内联效果，.home{background:url(data:image/gif;base64,RHJGYURTYVHGF)} .home{background-image:(data:image/gif;base64,&lt;?php echo base64_encode(file_get_contents(“../images/home.gif”))?&gt;)}合并js，多个js合并为1个（使用模块化js的时候，最后输出为1个即可） 2、使用内容分发网络cdncdn主要用于静态文件，如图片，css，js和flash等cdn，自动寻找离物理机最近的服务器下载web组件。 3、添加expires头通常图片添加Expires ，指定一个日期，Expires：Thu，15 Apr 2020 20:20:20 GMT，在这之前图片不过期，继续使用缓存（考虑问题：客户端和服务器时钟同步的问题）http1.1支持 max-age，Cache-Control：max-age=315460000，未来10年内缓存不会过期（当同时使用Cache-Control和Expires的时候，max-age=XXX，会自动重写Expires的日期）apache的mod_expires，设置相对过期时间，它同时发送Expires和max-age ExpiresDefault “access plus 10 years”&gt;即是不添加expires头，浏览器也会缓存，下次访问时，为了验证是否过期，只是发送一个很小的头，来服务器验证是否更新而已 4、压缩组件Accept-Encoding：gzip，deflate web服务器基于这个参数来检测是否对响应进行压缩 代理缓存的处理，在使用代理的时候，代理服务器为避免缓存版本不一致，故添加Vary头，Vary：Accrpt-Encoding，让代理缓存多个版本，一个是指定gzip压缩的版本，一个是没有指定压缩的版本 5、将样式表放在顶部 6、将脚本放在底部 w3c建议，浏览器每个主机名并行连个组件的下载禁用css表达式，这样css样式代码和css表达式逻辑代码混杂在一起了 7、使用外部css和js动态内联：根据cookie来做内联和外部的引用的选择第一次访问：生成内联组件的页面，服务器添加js代码，供页面加载后动态下载外部文件同时设置cookie第二次访问：服务器读取到了cookie，就生成一个外部文件的页面返回客户端 8、减少dns查找通过使用Keep-Alive和较少的域名来减少dns查找 9、精简js和css使用jsmint和gzip精简文件，css精简技术点：#660066 优化 #606 ，使用0代替0px 10、避免重定向]]></content>
      <categories>
        <category>性能</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
</search>