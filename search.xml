<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[web性能优化2]]></title>
    <url>%2F2017%2F07%2F30%2Fweb2%2F</url>
    <content type="text"><![CDATA[1、减少http请求a链接地图，减少图片链接css偏移内联图片：data:image/gif;base64,（ie不支持），css内联效果，.home{background:url(data:image/gif;base64,RHJGYURTYVHGF)} .home{background-image:(data:image/gif;base64,&lt;?php echo base64_encode(file_get_contents(“../images/home.gif”))?&gt;)}合并js，多个js合并为1个（使用模块化js的时候，最后输出为1个即可） 2、使用内容分发网络cdncdn主要用于静态文件，如图片，css，js和flash等cdn，自动寻找离物理机最近的服务器下载web组件。 3、添加expires头通常图片添加Expires ，指定一个日期，Expires：Thu，15 Apr 2020 20:20:20 GMT，在这之前图片不过期，继续使用缓存（考虑问题：客户端和服务器时钟同步的问题）http1.1支持 max-age，Cache-Control：max-age=315460000，未来10年内缓存不会过期（当同时使用Cache-Control和Expires的时候，max-age=XXX，会自动重写Expires的日期）apache的mod_expires，设置相对过期时间，它同时发送Expires和max-age ExpiresDefault “access plus 10 years”&gt;即是不添加expires头，浏览器也会缓存，下次访问时，为了验证是否过期，只是发送一个很小的头，来服务器验证是否更新而已 4、压缩组件Accept-Encoding：gzip，deflate web服务器基于这个参数来检测是否对响应进行压缩 代理缓存的处理，在使用代理的时候，代理服务器为避免缓存版本不一致，故添加Vary头，Vary：Accrpt-Encoding，让代理缓存多个版本，一个是指定gzip压缩的版本，一个是没有指定压缩的版本 5、将样式表放在顶部 6、将脚本放在底部 w3c建议，浏览器每个主机名并行连个组件的下载禁用css表达式，这样css样式代码和css表达式逻辑代码混杂在一起了 7、使用外部css和js动态内联：根据cookie来做内联和外部的引用的选择第一次访问：生成内联组件的页面，服务器添加js代码，供页面加载后动态下载外部文件同时设置cookie第二次访问：服务器读取到了cookie，就生成一个外部文件的页面返回客户端 8、减少dns查找通过使用Keep-Alive和较少的域名来减少dns查找 9、精简js和css使用jsmint和gzip精简文件，css精简技术点：#660066 优化 #606 ，使用0代替0px 10、避免重定向]]></content>
      <categories>
        <category>性能</category>
      </categories>
      <tags>
        <tag>Web2</tag>
        <tag>性能优化2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch配置文件]]></title>
    <url>%2F2017%2F07%2F29%2Felastic-conf%2F</url>
    <content type="text"><![CDATA[自动加载2.3版本开始，新增自动加载功能--auto-reload 12# 设置自动加载test.conf配置文件$ bin/logstash -f test.conf --auto-reload 默认每3秒监测一次配置文件，如果要修改该时间。 使用--reload-interval &lt;秒数&gt;参数 12# 设置每4秒读取一次test.conf配置文件$ bin/logstash -f test.conf --reload-interval 4]]></content>
      <categories>
        <category>Elastic</category>
      </categories>
      <tags>
        <tag>Elastic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch]]></title>
    <url>%2F2017%2F07%2F29%2Felastic%2F</url>
    <content type="text"><![CDATA[什么是Elasticsearch关于Elasticsearch的一些说明 Node（节点）：单个的装有Elasticsearch服务并提供故障转移和扩展的服务器 Cluster（集群）：一个集群就是由一个或多个node组织在一起，共同工作，共同分享整个数据具有负载均衡功能的集群 Document（文档）：一个文档是一个可被索引的基础信息单元 Index（索引）：索引就是一个拥有几分相似特征的文档集合 Type（类型）：一个索引中，你可以定义一种或躲着类型 Field（列）：Field是Elasticsearch的最小单位，相当于数据的某一列 Shards（分片）：Elasticsearch将索引分成若干份，每个部分就是一个shard Replicas（复制）：Replicas是索引一份或多份拷贝 与一般的关系型数据库的对比 关系型数据库（例如mysql） 非关系型数据库（Elasticsearch） 数据库Database 索引Index 表Table 类型Type 数据行Row 文档Document 数据列Column 字段Field 架构图 bulk批量操作 action（行为） 解释 create 当文档不存在时创建 index 创建新文档或替换已有的文档 update 局部更新文档 delete 删除一个文档 例：{&quot;delete&quot;:{&quot;_index&quot;:&quot;library&quot;,&quot;_type&quot;:&quot;books&quot;,&quot;_id&quot;:&quot;1&quot;}} 下面是一些批量操作 12345678910111213141516171819202122232425POST /librarys/books/_bulk&#123; &quot;index&quot;: &#123; &quot;_id&quot;:1 &#125; &#125;&#123; &quot;title&quot;:&quot;ELASTICSEARCH: THE DEFINETIVE GIDE2&quot;,&quot;price&quot;:5 &#125;&#123; &quot;index&quot;: &#123; &quot;_id&quot;:2 &#125; &#125;&#123; &quot;title&quot;:&quot;ELASTICSEARCH: cookbook2&quot;,&quot;price&quot;:51 &#125;&#123; &quot;index&quot;: &#123; &quot;_id&quot;:3 &#125; &#125;&#123; &quot;title&quot;:&quot;THINK IN PHP2&quot;,&quot;price&quot;:5 &#125;&#123; &quot;index&quot;: &#123; &quot;_id&quot;:4 &#125; &#125;&#123; &quot;title&quot;:&quot;THINK IN PATTERN&quot;,&quot;price&quot;:5 &#125;&#123; &quot;index&quot;: &#123; &quot;_id&quot;:5 &#125; &#125;&#123; &quot;title&quot;:&quot;HELLO WORLD&quot;,&quot;price&quot;:5 &#125;GET /librarys/books/_mget&#123; &quot;ids&quot; : [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;]&#125;POST /librarys/books/_bulk&#123; &quot;delete&quot;: &#123;&quot;_index&quot;: &quot;librarys&quot;, &quot;_type&quot;: &quot;books&quot;, &quot;_id&quot;: &quot;1&quot;&#125; &#125;&#123; &quot;create&quot;: &#123;&quot;_index&quot;: &quot;music&quot;,&quot;_type&quot;:&quot;classical&quot;,&quot;_id&quot;:&quot;1&quot;&#125;&#125;&#123; &quot;title&quot;: &quot;love is forvery&quot;&#125;&#123; &quot;index&quot;: &#123; &quot;_index&quot;: &quot;music&quot;, &quot;_type&quot;: &quot;classical&quot;&#125;&#125;&#123; &quot;title&quot;: &quot;live is forvery&quot;&#125;&#123; &quot;update&quot;: &#123; &quot;_index&quot;:&quot;librarys&quot;,&quot;_type&quot;:&quot;books&quot;,&quot;_id&quot;:&quot;2&quot;&#125;&#125;&#123; &quot;doc&quot;: &#123;&quot;price&quot;:&quot;99999&quot;&#125;&#125; PS:提交的Body数据必须一行一个action操作下一行为body数据，中间必须要用\n隔开 bulk处理文档大小的最佳值 数据加载在每个节点里的RAM里 请求的数据超过一定大小，那bulk的处理性能就会下降 文档数据大小跟硬件配置，文档复杂度，以及当前集群负载有关 PS:刚开始可以先处理小一点的数据，根据插件查看性能，如果没有问题再加大处理的数据 版本控制乐观锁和悲观锁悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作，并发量大的时候会产生性能阻塞，产生一些性能问题 乐观锁：假定不会发生并发冲突，只在提交操作时检查是否违反数据的完整性，如果提交时发现目标被修改了，会提交失败，同时会产生大量的查询操作，因为需要检查数据完整性，所以数据的实时性较差，读取的数据都是脏读、脏数据 内部版本和外部版本内部版本控制：使用自带的_version整型的自增长关键字，修改数据后，_version会自动加1 123456789101112131415161718192021222324252627282930# 新建一条数据，注意查看返回的_version关键字，版本为1PUT /librarys/books/1&#123; &quot;title&quot;: &quot;Elasticsearch: THE definetive guid&quot;, &quot;name&quot; : &#123; &quot;first&quot;:&quot;longjq&quot;, &quot;last&quot;:&quot;Tong&quot; &#125;, &quot;publish_date&quot;:&quot;2015-12-12&quot;, &quot;price&quot;:59.99&#125;# 查询id=1的数据，查看_version版本字段，版本为1GET /librarys/books/1# 修改id=1的数据中的字段，查看_version版本，版本为2，说明已修改成功POST /librarys/books/1/_update&#123; &quot;doc&quot;:&#123; &quot;price&quot;:15 &#125;&#125;# 指定修改id=1，version=2的数据，返回version=3，说明修改成功POST /librarys/books/1/_update?version=2&#123; &quot;doc&quot;:&#123; &quot;price&quot;:10 &#125;&#125; 外部版本控制：为了保持_version与外部版本控制的数值一致，使用version_type=external关键字，检查数据当前的version值是否小于请求中的version值，只有请求的version值大于数据中的version值的时候，才能修改成功 123456789101112131415161718192021222324# 覆盖操作，使用外部控制version_type=external参数，指定id=1的version的版本为version=15的版本PUT /librarys/books/1?version=15&amp;version_type=external&#123; &quot;title&quot;: &quot;Elasticsearch: THE definetive guid&quot;, &quot;name&quot; : &#123; &quot;first&quot;:&quot;longjq&quot;, &quot;last&quot;:&quot;Tong&quot; &#125;, &quot;publish_date&quot;:&quot;2015-12-12&quot;, &quot;price&quot;:33.33&#125;# 外部控制version版本与控制的版本一致时，操作失败，小于也失败，这里不演示，可自行操作，总而言之，给的version一定要大于数据中的version值PUT /librarys/books/1?version=15&amp;version_type=external&#123; &quot;title&quot;: &quot;Elasticsearch: THE definetive guid&quot;, &quot;name&quot; : &#123; &quot;first&quot;:&quot;longjq&quot;, &quot;last&quot;:&quot;Tong&quot; &#125;, &quot;publish_date&quot;:&quot;2015-12-12&quot;, &quot;price&quot;:33.33&#125;GET /librarys/books/1 PS:给定version时，其值必须为整型 Mapping 映射什么是Mapping映射就是类似于mysql的表结构，创建索引的时候，预先定义相关字段的类型以及相关的属性 PS：如果没有设置映射的话，Elasticsearch会自动分析数据内容，创建字段的映射，这里可以理解为手动设置映射关系 它有什么用让索引建立的更加细致和完善 映射的分类分为静态映射和动态映射 字段类型去官网查看 PS:记录该学习笔记的时候，使用的是Elasticsearch 2.3的版本 以下截图为常用字段，2.3版本新增了很多字段，建议去官网查看 属性方法去官网查看 除了定义字段类型，还可以给字段添加相关属性 如何理解这个属性方法？ 字段类型是约束存入的数据类型格式，属性方法是给该位置的字段添加相关的属性，属性不同会产生不同的效果，类似于mysql的default、主键、自增长 截图是常用属性方法 动态映射 什么是动态映射 文档中碰到一个以前没见过的字段时，动态映射自动决定该字段的类型，并对该字段添加映射 如何配置动态映射 通过dynamic属性进行控制 true：默认值，动态添加自动；false：忽略新自动；strict：碰到陌生自动，抛出异常。 适用范围 适用在根对象上或者object类型的任意字段上 代码演示 建立和查看映射 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# 建立映射POST /library&#123; "settings": &#123; "number_of_shards":5, "number_of_replicas": 1 &#125;, "mappings": &#123; "books": &#123; "properties": &#123; "title": &#123; "type": "string" &#125;, "name": &#123; "type": "string", "index": "not_analyzed" &#125;, "publish_date": &#123; "type": "date", "index" : "not_analyzed"&#125;, "price": &#123; "type": "double" &#125;, "number": &#123; "type": "integer" &#125; &#125; &#125; &#125;&#125;# 动态映射(注意：2.3的版本貌似已经修改，该处建议查看官网文档)PUT /library&#123; "mappings": &#123; "books": &#123; "dynamic": "strict", "properties": &#123; "title": &#123; "type": "string" &#125;, "name": &#123; "type": "string", "index": "not_analyzed" &#125;, "publish_date": &#123; "type": "date", "index" : "not_analyzed"&#125;, "price": &#123; "type": "double" &#125;, "number": &#123; "type": "object", "dynamic": true &#125; &#125; &#125; &#125;&#125;# 查看library索引信息，包含映射信息GET /library# 获取library索引映射信息GET /library/_mapping# 获取library索引下的books映射信息GET /library/_mapping/books# 获取整个集群内的索引信息GET /_all/_mapping# 获取整个集群内的type为books和music的映射信息GET /_all/_mapping/books,music 删除映射 123# 删除映射DELETE /library/books/_mappingDELETE /library/_mapping/books 更新映射 很遗憾，Mapping映射一旦建立，就不能修改！！！ 只能新建另外一个索引，然后将之前的数据导入到新的索引中 ————操作方法—————1.给现有索引定义一个别名，并且把现有的索引指向这个别名 1PUT /现有索引/_alias/别名A 2.新创建一个索引，定义好需要的映射 3.把别名指向新的索引，并取消之前的索引的指向 1234567POST /_aliases&#123; &quot;actions&quot;:[ &#123; &quot;remove&quot;: &#123; &quot;index&quot;: &quot;现有索引名&quot;,&quot;alias&quot;: &quot;别名A&quot; &#125; &#125;， &#123; &quot;add&quot;: &#123; &quot;index&quot;: &quot;新建索引名&quot;,&quot;alias&quot;: &quot;别名A&quot; &#125; &#125;， ]&#125; 通过以上三步骤可实现索引平衡过渡，且是零停机执行 查询基本查询利用Elasticsearch内置查询条件进行查询，文档最后有示例数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061GET /library/books/# 指定index名以及type名的搜索GET /library/books/_search?q=title:ELASTICSEARCH# 指定index名没有type名的搜索，跨type类型搜索GET /library/_search?q=title:ELASTICSEARCH# 没有index名也没有type名的搜索，跨index索引搜索GET /_search?q=title:ELASTICSEARCH#------------------------------------------------# term查询# term查询：查询某字段里有某个关键字的文档GET /library/books/_search&#123; "query": &#123; "term": &#123; "preview": "ut" &#125; &#125;&#125;# terms查询：查询某个字段有多个关键词的文档# minimum_match：最小匹配，1 说明两个关键词里最少要有一个 2 说明文档这两个关键词必须存在# minimum_match 该参数在2.3的版本中不支持在terms中使用了，请去官网查询GET /library/books/_search&#123; "query":&#123; "terms": &#123; "preview": [ "doloremque", "Odit" ], "minimum_match": 2 &#125; &#125;&#125;# -----------------------------------------------GET /library/books/_search?q=title:ELASTICSEARCH# 控制查询返回数量# 相当于mysql中的limit# form ：从哪个结果开始返回，2.3版本中，整型变量变成了对象，请去官网查询# size ：定义返回最大的结果数GET /library/books/_search&#123; "from": 0, "size": 20, "query": &#123; "term": &#123; "title": &#123; "value": "ELASTICSEARCH" &#125; &#125; &#125;&#125; 组合查询把多个基本查询组合在一起的复合性查询 过滤查询同时，通过filter条件在不影响打分的情况下筛选出想要的数据 library数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162[ &#123; "title": "minima", "price": 49.45, "preview": "Earum inventore velit quidem incidunt alias rem esse pariatur. Laborum sed quo nulla consectetur voluptatem consequatur delectus. Culpa quo tempora atque explicabo sed officia eos consequatur.", "publish_date": "2011-02-13" &#125;, &#123; "title": "eveniet", "price": 46.59, "preview": "Aliquam necessitatibus nostrum pariatur ut hic. Voluptatum rerum occaecati natus nostrum dolor. Quibusdam omnis quod voluptas nostrum.", "publish_date": "1986-10-27" &#125;, &#123; "title": "voluptatem", "price": 29.99, "preview": "Voluptatem a recusandae inventore error. Ut et beatae nulla enim saepe et. Pariatur fuga quam ut. Ducimus qui ut est ut dolor.", "publish_date": "2012-07-12" &#125;, &#123; "title": "tempore", "price": 74.42, "preview": "Eveniet facilis dolor repellat nesciunt eum quas. Ipsa ab harum et et. Autem fuga voluptas modi omnis ad et. Inventore in autem cum atque molestiae odit perferendis.", "publish_date": "1981-11-26" &#125;, &#123; "title": "voluptatem", "price": 99.97, "preview": "Dolores quis expedita libero id neque. Non est culpa perspiciatis repudiandae deserunt quaerat eius. Quo laboriosam officiis voluptate voluptas quia corporis ut.", "publish_date": "1987-01-05" &#125;, &#123; "title": "dolores", "price": 35.27, "preview": "Porro atque necessitatibus sed doloremque qui. Enim dolores illum dolorum qui incidunt.", "publish_date": "2006-03-19" &#125;, &#123; "title": "pariatur", "price": 22.87, "preview": "Quis facere blanditiis voluptatem at non aperiam ab ut. Voluptatum ipsum necessitatibus et et. Voluptatem culpa quia architecto. Deleniti aut officia temporibus est.", "publish_date": "1982-09-09" &#125;, &#123; "title": "et", "price": 37.13, "preview": "Odit doloremque magni accusamus cupiditate soluta nam assumenda qui. Labore nulla voluptatem reiciendis. Excepturi ex sapiente dolor aut totam provident. Velit et ut adipisci quaerat nihil qui.", "publish_date": "2015-09-25" &#125;, &#123; "title": "maxime", "price": 8.78, "preview": "Quaerat eos repudiandae inventore. Voluptates qui est illum ad sed. Necessitatibus ab pariatur quod.", "publish_date": "2011-10-31" &#125;, &#123; "title": "aspernatur", "price": 40.39, "preview": "Aut quibusdam tempora rerum. Doloremque tempore laborum dolores mollitia fugiat. Nemo blanditiis exercitationem occaecati modi repudiandae.", "publish_date": "2008-01-06" &#125;]]]></content>
      <categories>
        <category>Elastic</category>
      </categories>
      <tags>
        <tag>Elastic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F07%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[web性能优化]]></title>
    <url>%2F2017%2F07%2F29%2Fweb%2F</url>
    <content type="text"><![CDATA[1、减少http请求a链接地图，减少图片链接css偏移内联图片：data:image/gif;base64,（ie不支持），css内联效果，.home{background:url(data:image/gif;base64,RHJGYURTYVHGF)} .home{background-image:(data:image/gif;base64,&lt;?php echo base64_encode(file_get_contents(“../images/home.gif”))?&gt;)}合并js，多个js合并为1个（使用模块化js的时候，最后输出为1个即可） 2、使用内容分发网络cdncdn主要用于静态文件，如图片，css，js和flash等cdn，自动寻找离物理机最近的服务器下载web组件。 3、添加expires头通常图片添加Expires ，指定一个日期，Expires：Thu，15 Apr 2020 20:20:20 GMT，在这之前图片不过期，继续使用缓存（考虑问题：客户端和服务器时钟同步的问题）http1.1支持 max-age，Cache-Control：max-age=315460000，未来10年内缓存不会过期（当同时使用Cache-Control和Expires的时候，max-age=XXX，会自动重写Expires的日期）apache的mod_expires，设置相对过期时间，它同时发送Expires和max-age ExpiresDefault “access plus 10 years”&gt;即是不添加expires头，浏览器也会缓存，下次访问时，为了验证是否过期，只是发送一个很小的头，来服务器验证是否更新而已 4、压缩组件Accept-Encoding：gzip，deflate web服务器基于这个参数来检测是否对响应进行压缩 代理缓存的处理，在使用代理的时候，代理服务器为避免缓存版本不一致，故添加Vary头，Vary：Accrpt-Encoding，让代理缓存多个版本，一个是指定gzip压缩的版本，一个是没有指定压缩的版本 5、将样式表放在顶部 6、将脚本放在底部 w3c建议，浏览器每个主机名并行连个组件的下载禁用css表达式，这样css样式代码和css表达式逻辑代码混杂在一起了 7、使用外部css和js动态内联：根据cookie来做内联和外部的引用的选择第一次访问：生成内联组件的页面，服务器添加js代码，供页面加载后动态下载外部文件同时设置cookie第二次访问：服务器读取到了cookie，就生成一个外部文件的页面返回客户端 8、减少dns查找通过使用Keep-Alive和较少的域名来减少dns查找 9、精简js和css使用jsmint和gzip精简文件，css精简技术点：#660066 优化 #606 ，使用0代替0px 10、避免重定向]]></content>
      <categories>
        <category>性能</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
</search>